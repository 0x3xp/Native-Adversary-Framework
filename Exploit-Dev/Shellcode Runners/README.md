# Shellcode Runners

This directory explores the design and implementation of loaders used to execute position-independent shellcode within a target process. The research focuses on various execution vectors, memory management techniques, and evasion strategies to bypass static and dynamic analysis.

---

## ðŸ›  Key Areas
* **Memory Allocation & Permissions:** Utilizing Windows APIs (e.g., `VirtualAlloc`, `VirtualProtect`) to transition memory states. Focus is on avoiding **RWX** (Read-Write-Execute) markers, which are high-signal telemetry for EDRs.
* **Execution Vectors:** Implementing various methods to redirect execution flow, including direct function pointers, **Asynchronous Procedure Calls (APC)**, and thread hijacking.
* **Evasion & Obfuscation:** Techniques to hide shellcode in non-traditional sections, such as `.data` or `.rsrc`, and utilizing **XOR/AES encryption** to bypass signature-based detection.
* **API Unhooking & Syscalls:** Bypassing User-mode hooks by manually invoking **Direct Syscalls** or loading "fresh" copies of `ntdll.dll` to mask the runner's intent from monitoring tools.



---

## ðŸ“ Content
* **/Classic-Injection:** Standard `OpenProcess` â†’ `VirtualAllocEx` â†’ `WriteProcessMemory` â†’ `CreateRemoteThread` implementations in C++.
* **/Local-Execution:** Lightweight stubs for executing shellcode within the runner's own memory space for rapid testing.
* **/Process-Hollowing:** Advanced techniques for carving out a legitimate process (e.g., `svchost.exe`) and replacing its image with custom code.
* **/Anti-Analysis:** Snippets for sandbox detection, timing checks, and environmental keying to prevent execution in VM/Analyst environments.

---

> **Note:** These runners are intended for research and authorized penetration testing only. All implementations prioritize manual control over Windows internals to minimize the footprint of the execution stub.
